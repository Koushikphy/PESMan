import re
import sqlite3 
import numpy as np 
import itertools
from glob import glob
# initiate the geometry object inside the geometry file  and call the methods from there
# this is benificial for normal mode as the code doesn't have to  initite the object for every geometry
from geometry import geomObj


def parseResult(file):
    # reads a file and returns the result as a string
    with open(file, 'r') as f:
        txt = f.read()
    txt = txt.replace('D','E')
    res = re.findall(r"(?:(?<=^)|(?<=\s))([+-]?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)(?=\s|$|\n|\r\n)", txt)
    return ' '.join(res)






def GenCalcFile(CalcId,GeomId,CalcName,Record,Basename,Desc="",Aux="",fileName= 'tmp'):

    txt = """# This file is automatically generated.Do not edit, unless you are sure of what you are changing.
    CalcId   : {}
    GeomId   : {}
    Name     : {}
    Record   : {}
    Basename : {}
    Desc     : {}
    Aux      : {}""".format(CalcId,GeomId,CalcName,Record,Basename,Desc,Aux)

    with open(fileName, "w") as f:
        f.write(txt)



def ExportNearNbrJobs(Args):
    """ Export a number of Jobs. This one is the general export.
        Algorithm is described in GetExpGeomNearNbr function.
        Parameters are also described there.
    """

    # Mrci or nact export
    if Args.CalcTypeId > 1:
        ExpGeomList = GetExpMrciNactJobs(Args.DbMain,Args.CalcTypeId, totGeom=Args.NumJobs,ConstDb=Args.ConstDb)
    else:
        ExpGeomList = GetExpGeomNearNbr(Args.DbMain,Args.CalcTypeId, Args.GeomIdList,
                                        Args.StartIdList,totGeom=Args.NumJobs,NbrDepth=Args.Depth,NbrDb=Args.DbNbr,
                                        ConstDb=Args.ConstDb,bIncludePath=Args.IncludePath)

    # ExpGeomList will always have some value as blank return is blocked in new style

    with sqlite3.connect(Args.DbMain) as con:
        
        con.row_factory=sqlite3.Row
        # first find info about this calculation type
        cur.execute('SELECT * from CalcInfo WHERE Id=?',(Args.CalcTypeId,))
        InfoRow = cur.fetchone()

        cur.execute("INSERT INTO Exports (Type,CalcType) VALUES (?,?)", (0,Args.CalcTypeId))
        ExportId = cur.lastrowid

        ExpDir = "{}/Export{}-{}{}".format(Args.ExportDir, ExportId, InfoRow[0], Args.CalcTypeId)
        os.makedirs(ExpDir)

        # prepare a list of geometries to be exported with suffix
        ExpGeomListSuffix = []
        nExp = len(ExpGeomList)
        
        #! why is this needed?
        for i in range(nExp):
            s = str(i+1)
            ExpGeomListSuffix.append(ExpGeomList[i]+(s,)) 


        # now export all geometries, this will create all subdirectories
        ExportedDirList = ExportGeometries(Args,ExpGeomListSuffix,ExpDir)

        # if this is successful, then we need to update the Exports table
        cur.execute("UPDATE Exports SET Type=0, NumCalc=?, ExpDir=?, ExpDT=datetime('now','localtime') WHERE Id=?",\
                    (len(ExportedDirList),os.path.abspath(ExpDir),ExportId))

        # we will also need to enter exported geometries in ExpCalc table
        # assert(len(ExportedDirList) == len(ExpGeomListSuffix))
        lexpcalc = []
        for i in range(len(ExportedDirList)):
            lexpcalc.append((ExportId,ExpGeomListSuffix[i][0],ExportedDirList[i]))

        cur.executemany("INSERT INTO ExpCalc (ExpId,GeomId,CalcDir) VALUES (?,?,?)",lexpcalc)


        # making export.dat a little bit simplified first value is export id and rest are the directoris
        fExportDat = ExpDir + "/" + "export.dat"
        with open(fExportDat,'w') as f:
            f.write("# Auto generated file. Please do not modify\n"+ ' '.join([ExportId]+ExportedDirList))

        # change mode of this file to read-only to prevent accidental writes
        os.chmod(fExportDat,0444)

        # if Args.Verbose:
        #    print "Export with ExportId =", ExportId, " has been entered into data base ", Args.DbMain

        # the python file needs to be generated
        fPythonFile = ExpDir + "/" + "RunJob" + str(ExportId) + ".py"
        with open(fPythonFile,'w') as f:
            f.write(sRunJobPythonFilePrefix)
            f.write("\n")





#! Gurantee that no blank export is done
#! Put calcid in expcalc
#! remove gidsingle
def GetExpGeomNearNbr(Db,CalcTypeId,GidList=[],SidList=[],totGeom=1,NbrDepth=1,NbrDb="",ConstDb="",bIncludePath=False):

    with sqlite3.connect(Db) as con:
        cur = con.cursor()
        # not using row factory with the database api
        # notice getting GeomId,Id to easily feed into dictionary
        cur.execute("SELECT GeomId,Id FROM Calc WHERE CalcId=?",(CalcTypeId,))
        calcRow = cur.fetchall()

        # if len(calcRow)<totGeom:
        #     raise Exception("Not enough number of completed calculations present in database")

        # a set of geomIds that is already done
        CalcGeomIds = set([geomId for geomId,_ in calcRow ])
        DictCalcId  = dict(calcRow)

        # set of geomIds that will be excluded from exporting
        ExcludeGeomIds = CalcGeomIds.copy()

        if not bIncludePath:
            cur.execute("SELECT Id FROM Geometry WHERE tags LIKE '%path%'")
            ExcludeGeomIds.update(cur.fetchall())


        #! also adding the status, will trim the expcalc search heavily... Try to get geomids from expcalc
        # cur.execute("SELECT ID FROM Exports WHERE CalcType=?",(CalcTypeId,))
        cur.execute("SELECT ID FROM Exports WHERE status=0 CalcType=?",(CalcTypeId,))
        for expId in cur:
            cur.execute("SELECT GeomId FROM ExpCalc WHERE ExpId=?",(expId,))
                ExcludeGeomIds.update(cur.fetchall())


    #--------------------------------------------------------------------------------
        # lPrblmGeomIds = []
        # ExcludeGeomIds.update(lPrblmGeomIds)
    #--------------------------------------------------------------------------------

        DictStartId = {}
        GidListNew = []

        for g,s in itertools.izip_longest(GidList,SidList):
            if (g in ExcludeGeomIds) or (s==None):
                DictStartId[g] = -1
                GidListNew.append(0)    #<--- why adding geomlist here?
            else:
                DictStartId[g] = s
                GidListNew.append(geom)


        sql = "SELECT Id,Nbr FROM Geometry"
        if GidListNew and ConstDb :
            sql += "where id in (" + ",".join([str(i) for i in GidListNew]) + ") and (" + ConstDb + ")"
        elif GidListNew and not ConstDb:
            sql += "where id in (" + ",".join([str(i) for i in GidListNew]) + ")"
        elif not GidListNew and ConstDb:
            sql += "where "  + ConstDb
        cur.execute(sql)

        # this is only useful only if one gives jobs number less than the gid list length
        # if GidListNew: 
        #     # so when gid list given cur is simple list o/w cur is sqlite iterator. 
        #     # is this bad?,  the cur sqlite instance is not needed after this point
        #     cur = cur.fetchall() 
        #     totGeom = len(cur)

        expGClist = []

        # ExcludeGeomIds and CalcGeomIds are sets for faster searching
        for GeomId, nbrList in cur:
            if len(expGClist)==totGeom: break     # got all the geometries needed
            if GeomId in ExcludeGeomIds: continue # geometry already exist, skip

            for depth, nId in enumerate(nbrList.split(), start=1):
                NbrId = int(nId)
                if not maxDepth and (depth>maxDepth): break 

                if GidListNew and DictStartId[GeomId]>=0: # only if start id is negetive then we have to search neighbour list
                    NbrId = DictStartId[GeomId]
                    if not NbrId: # zero startid
                        expGClist.append([GeomId, 0])
                        break

                if NbrId in CalcGeomIds:
                    expGClist.append([GeomId, DictCalcId[NbrId]])
                    break # got one match now don't search for other neighbours

    # preventing null exports
    assert len(expGClist), "Can't export any geometries"
    return expGClist




def GetExpMrciNactJobs(Db,CalcTypeId,totGeom=50,constDb=""):
    """ Returns a list of geometries for MRCI or NACT calc- to be exported.
        A list of (GeomId,CalcId) is returned where
            GeomId : geometry to be exported
            CalcId : the id in calc table which corresponds to calc of calctypeid = 1 of the GeomId.
        This will return an empty list if it can not export.
    """

   with sqlite3.connect(Db) as con:
        cur = con.cursor()

        cur.execute("SELECT Id FROM Calc WHERE CalcId=?",(CalcTypeId,))
        CalcGeomIds = set(cur.fetchall())
        ExcludeGeomIds = CalcGeomIds.copy()

        cur.execute("SELECT ID FROM Exports WHERE status=0 CalcType=?",(CalcTypeId,))
        for expId in cur:
            cur.execute("SELECT GeomId FROM ExpCalc WHERE ExpId=?",(expId,))
                ExcludeGeomIds.update(cur.fetchall())

    #--------------------------------------------------------------------------------
        # lPrblmGeomIds = []
        # ExcludeGeomIds.update(lPrblmGeomIds)
    #--------------------------------------------------------------------------------
        if constDb:
            cur.execute("SELECT Id FROM Geometry where " + constDb )
            ConstGeomIds = set(cur.fetchall())

        expGClist = []

        cur.execute("SELECT Id,GeomId FROM Calc WHERE CalcId = 1")
        for StartId, GeonId in cur:
            if constDb and (GeomId not in ConstGeomIds): # this is a small list so checking it before excludelist
                continue
            if (GeomId not in ExcludeGeomIds):
                expGClist.append([GeomId, StartId])
                if len(expGClist)==totGeom: break

    # preventing null exports
    assert len(expGClist), "Can't export any geometries"
    return expGClist



def ExportGeometries(Args,ExportList,ExpDir):
   """ this exports a list of geometries to separate directories """


   ExportedDirs = []
   for (GeomId,StartCalcId,BaseSuffix) in ExportList:
      BaseName = ExportCalc(Args.DbMain,GeomId,Args.CalcTypeId,Args.PESDir,ExpDir,
                            ComTemplate=Args.ComTemplate,StartId=StartCalcId,
                            BaseSuffix=BaseSuffix,Verbose=Args.Verbose)
      # collect list of base names exported
      ExportedDirs.append(BaseName)

   return ExportedDirs




def ExportCalc(Db,GeomId,CalcTypeId,DataDir,ExpDir,ComTemplate="",StartId=0,BaseSuffix="",Verbose=False):

    with sqlite3.connect(Db) as con:

        # use row factory which is far better and has dictionary-like access to data
        con.row_factory = sqlite3.Row
        cur = con.cursor()

        # GeomId and CalcTypeId check
        cur.execute('SELECT * from Geometry WHERE Id=?',(GeomId,))
        GeomRow = cur.fetchone()
        cur.execute('SELECT * from CalcInfo WHERE Id=?',(CalcTypeId,))
        InfoRow= cur.fetchone()

        # removed al lot of things from here

        if ComTemplate:
            with open(ComTemplate,'r') as f:
            InpTempl = f.read()
        else:
            InpTempl = InfoRow["InpTempl"]
        Record = InfoRow["OrbRec"]

        # if StartId is non-zero, then it must exist in Calc table.
        # we gather details necessary for setting up such input
        # we need:
        #    wfn file of calculation
        #    the record number of orbitals
        bUnzip = False
        if StartId:
            cur.execute('SELECT * from Calc WHERE Id=?',(StartId,))
            # start_row = cur.fetchall()  # this should always return one element, checked already before
            # assert (len(start_row) == 1)
            # StartCalcRow = start_row[0]
            StartCalcRow = cur.fetchone()
            # pickup details from here -- needed for completing template file
            StartGId = StartCalcRow["GeomId"]
            StartDir = DataDir + "/" + StartCalcRow["Dir"]
            StartWfnFile = StartCalcRow["WfnFile"]
            StartRecord = StartCalcRow["OrbRec"]
            # check access for wave-function -- it could be a zip file
            misc.CheckDirAccess(StartDir,bRead=True,bAssert=True)
            if misc.CheckFileAccess(StartDir + "/" + StartWfnFile,bRead=True,bAssert=False):
                bUnzip = False
            elif misc.CheckFileAccess(StartDir + "/" + StartWfnFile + ".gz",bRead=True,bAssert=False):
                bUnzip = True
            else:
                raise Exception("Wavefunction file=%r does not exist" %(StartWfnFile,))
        # else:
        #     StartGId = 0


        # decide basename needed for generated files
        BaseName = "{}{}-geom.wfu".format(InfoRow["Type"], CalcTypeId, GeomId)
        if BaseSuffix:
            BaseName = BaseName + "-" + BaseSuffix


        ExportDir = ExpDir + "/" + BaseName
        os.makedirs(ExportDir,0775)

        # # now we are ready to generate files, first calc and xyz files
        # sCalcFile = GenCalcFile(CalcTypeId,GeomId,CalcName,Record,BaseName,Desc="",Aux="Start GId - " + str(StartGId))
        # # #! This is bad, something so inside of a library mustn't be hardcoded with outside dependencies
        # # #! get this out of here immediately
        # # GeomObj = geometry.Geometry(GeomRow["sr"],GeomRow["cr"],GeomRow["theta"],id=GeomId)
        # # #! also make the xyz file outside
        # # sXYZFile = GeomObj.to_xyzstr()



        # write them out
        # for calc file, we will generate it as .calc_ <--- note extra underscore at end
        # this is to safegaurd against faulty imports.
        # this should be renamed to .calc upon successful run
        fCalc = ExportDir + "/" + BaseName + ".calc_"  # <-- extra underscore
        fXYZ  = ExportDir + "/" + BaseName + ".xyz"
        # get these file writes inside of there respective functions
        GenCalcFile(CalcTypeId,GeomId,CalcName,Record,BaseName,Desc="",Aux="Start GId - " + str(StartGId), fileName=fCalc)
        # now only modify the createXYZ file methode inside the geometry file
        geomObj.createXYZfile(GeomRow, filename = fXYZ)



        # if wfn file needs to be copied from elsewhere, do that now
        if StartId:
            fSrcWfn = StartDir + "/" + StartWfnFile # this has .wfu extension already
            fDstWfn = ExportDir + "/" + BaseName + ".wfu"
            if bUnzip:
                fSrcWfn += ".gz"
                fDstWfn += ".gz"
            shutil.copy(fSrcWfn,fDstWfn)
            if bUnzip:
                subprocess.call(["gzip", "-d", fDstWfn])


        txt = InpTempl.replace("$F$",BaseName).replace("$R$",Record)
        if StartId:
            txt = txt.replace("$S$",StartRecord)
        else:
            print("WARNING: template not fully substituted -- check input file")
        # generate input file
        fInp = ExportDir + "/" + BaseName + ".com" 
        with open(fInp,'w') as f:
            f.write(txt)






def ImportNearNbrJobs(Args):
    Db = Args.DbMain
    ExportDir = os.path.abspath(os.path.dirname(Args.ExpFile))
    DataDir = Args.PESDir
    ExportId = Args.ExportId # useless
    # this function is called with the export.dat file so we dont have to check if exportid is given or not. It's obviously not given

    fExpDat = ExportDir + "/export.dat"
    with open(fExpDat,'r') as f:
        ExportId, sExpDat = f.read().split("\n",1)

    ExportId = int(ExportId)
    CalcDirs = sExpDat.split()
    CalcDirsDone = set([d for d in CalcDirs if os.path.isfile(ExportDir + "/" + d + "/" + d + ".calc")])

    with sqlite3.connect(Db) as con:
        cur = con.cursor()
        cur.execute('SELECT Status FROM Exports WHERE Id=?',(ExportId,))
        exp_row = cur.fetchone()
        assert exp_row,        "Export Id = {} not found in data base".format(ExportId)
        assert exp_row[0] ==0, "Export Id = {} is already closed.".format(ExportId)

        # now obtain list of jobs which can be imported.
        cur.execute("SELECT GeomId,CalcDir FROM ExpCalc where ExpId=?",(ExportId,))

        importCount = 0
        for geomId, calcDir in cur:
            if calcDir in CalcDirsDone:

                dirFull = ExportDir + "/" + calcDir
                cFiles = glob(dirFull+"*.calc")
                assert len(cFiles)==1, "{} has {} .calc file(s)".format(dirFull, len(cFiles))
                
                print("Importing ...",CalcDir,"...",)
                ImportCalc(con,dirFull,cFiles[0],DataDir)
                print("done")

                cur.execute('DELETE FROM ExpCalc WHERE ExpId=? AND GeomId=? ',(ExportId,geomId))
                importCount+=0

        sImpGeomIds =''# update what geometries are imported with this exportid
        cur.execute("UPDATE Exports SET ImpDT=datetime('now','localtime'), ImpGeomIds=? WHERE Id=?",(sImpGeomIds,ExportId))


        # status in export table will be 1 only if all geometries are imported, i.e. all jobs ran successfully
        # i.e all calcdirs has `.calc` file , so   # a tricky way to curb some calculation, BEWARE
        if len(CalcDirs) == len(CalcDirsDone):
            cur.execute("UPDATE Exports SET Status=1 WHERE Id=?",(ExportId,))
            print('Export Id={} is now closed.'.format(ExportId))
        else :
            print('Export Id={} is not closed.'.format(ExportId))

    print("{} Jobs have been successfully imported.".format(GeomIdsToImport))



def ImportCalc(con,CalcDir,CalcFile,DataDir):

    # parse calcfile and get basename
    # this is to identify the files to be imported.
    with open(CalcFile,'r') as f:
        txt = f.read().split("\n")[1:]
    dCalc = dict([map(str.strip, i.split(":")) for i in txt])

    try:
        with con: # this context manager automatecally commits and roll back for us
            sResults = parseResult(fRes)
            a,b,_ = dCalc['Baseame'].split('-') # a base name `multinact2-geom111-1` will go `GeomData/geom111/multinact2`
            DestCalcDir = "{}/{}".format(b,a)  #  simple trick check throughly
            if not os.path.exists(DestCalcDir):
                os.makedirs(DestCalcDir)

            tcalc = (dCalc["GEOMID"],dCalc["CALCID"],dCalc["AUX"],sResults)

            con.execute("INSERT INTO Calc (GeomId,CalcId,AuxFiles,Results) VALUES (?, ?, ?, ?)", tcalc) # not standard but whatever

            ignoreList = []   # put file extension that you dont want to export, should be passed through argument
            for iFile in glob("{}/*.*".format(CalcDir)):
                if os.path.splitext(iFile)[1] in ignoreList:
                    continue
                oFile = DestCalcDir + "/" + re.sub('-\d+','',iFile)   # a file `multinact2-geom111-1.com` will be `multinact2-geom111.com` in Geomdata
                iFile = CalcDir+"/"+iFile                               #  simple trick check throughly
                shutil.copy(oFile, iFile)

        # subprocess.call(["gzip", "-9", DestCalcDir + "/" + fDbWfu])
    except Exception as e:
        print("Something went wrong %s"%e)
