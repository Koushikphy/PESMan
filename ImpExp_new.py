import re
import sqlite3 
import numpy as np 
import itertools


def parseResult(file):
    # reads a file and returns the result as a string
    with open(file, 'r') as f:
        txt = f.read()
    txt = txt.replace('D','E')
    res = re.findall(r"(?:(?<=^)|(?<=\s))([+-]?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)(?=\s|$|\n|\r\n)", txt)
    return ' '.join(res)



def GenCalcFile(CalcId,GeomId,CalcName,Record,Basename,Desc="",Aux=""):

    sheader = """
        # This file is automatically generated.
        # The defaults are usually sufficient for import.
        # Do not edit, unless you are sure of what you are changing.
        #
    """
    scalc = "CalcId   : " + str(CalcId)
    sgeom = "GeomId   : " + str(GeomId)
    sname = "Name     : " + str(CalcName)
    srec  = "Record   : " + str(Record)
    sbase = "Basename : " + str(Basename)
    sdesc = "Desc     : " + str(Desc)
    saux  = "Aux      : " + str(Aux)

    return "\n".join([sheader,scalc,sgeom,sname,srec,sbase,sdesc,saux]) + "\n"



def ExportNearNbrJobs(Args):
    """ Export a number of Jobs. This one is the general export.
        Algorithm is described in GetExpGeomNearNbr function.
        Parameters are also described there.
    """

    # Mrci or nact export
    if Args.CalcTypeId > 1:
        ExpGeomList = GetExpMrciNactJobs(Args.DbMain,Args.CalcTypeId, totGeom=Args.NumJobs,ConstDb=Args.ConstDb)
    else:
        ExpGeomList = GetExpGeomNearNbr(Args.DbMain,Args.CalcTypeId, Args.GeomIdList,
                                        Args.StartIdList,totGeom=Args.NumJobs,NbrDepth=Args.Depth,NbrDb=Args.DbNbr,
                                        ConstDb=Args.ConstDb,bIncludePath=Args.IncludePath)

    # ExpGeomList will always have some value as blank return is blocked 

    with sqlite3.connect(Args.DbMain) as con:
        
        con.row_factory=sqlite3.Row
        # first find info about this calculation type
        cur.execute('SELECT * from CalcInfo WHERE Id=?',(Args.CalcTypeId,))
        InfoRow = cur.fetchone()

        cur.execute("INSERT INTO Exports (Type,CalcType) VALUES (?,?)", (0,Args.CalcTypeId))
        ExportId = cur.lastrowid

        ExpDir = "{}/Export{}-{}{}".format(Args.ExportDir, ExportId, InfoRow[0], Args.CalcTypeId)
        os.makedirs(ExpDir)

        # prepare a list of geometries to be exported with suffix
        ExpGeomListSuffix = []
        nExp = len(ExpGeomList)
        
        #! why is this needed?
        for i in range(nExp):
            s = str(i+1)
            ExpGeomListSuffix.append(ExpGeomList[i]+(s,)) 


        # now export all geometries, this will create all subdirectories
        ExportedDirList = ExportGeometries(Args,ExpGeomListSuffix,ExpDir)

        # if this is successful, then we need to update the Exports table
        cur.execute("UPDATE Exports SET Type=0, NumCalc=?, ExpDir=?, ExpDT=datetime('now','localtime') WHERE Id=?",\
                    (len(ExportedDirList),os.path.abspath(ExpDir),ExportId))

        # we will also need to enter exported geometries in ExpCalc table
        # assert(len(ExportedDirList) == len(ExpGeomListSuffix))
        lexpcalc = []
        for i in range(len(ExportedDirList)):
            lexpcalc.append((ExportId,ExpGeomListSuffix[i][0],ExportedDirList[i]))

        cur.executemany("INSERT INTO ExpCalc (ExpId,GeomId,CalcDir) VALUES (?,?,?)",lexpcalc)

        # commit the changes      
        # con.commit()

        # now, we are almost done!
        # we need to generate remaining files
        fExportDat = ExpDir + "/" + "export.dat"
        with open(fExportDat,'w') as f:
            f.write("# Auto generated file. Please do not modify\n")
            f.write("ExpId : " + str(ExportId))
            f.write("\n")
            f.write("CalcDirs : " + " ".join(ExportedDirList))
            f.write("\n")
            f.close()
        # change mode of this file to read-only to prevent accidental writes
        os.chmod(fExportDat,0444)

        # if Args.Verbose:
        #    print "Export with ExportId =", ExportId, " has been entered into data base ", Args.DbMain

        # the python file needs to be generated
        fPythonFile = ExpDir + "/" + "RunJob" + str(ExportId) + ".py"
        with open(fPythonFile,'w') as f:
            f.write(sRunJobPythonFilePrefix)
            f.write("\n")
            f.close()




#! Gurantee that no blank export is done
#! Put calcid in expcalc
#! remove gidsingle
def GetExpGeomNearNbr(Db,CalcTypeId,GidList=[],SidList=[],totGeom=1,NbrDepth=1,NbrDb="",ConstDb="",bIncludePath=False):

    with sqlite3.connect(Db) as con:
        cur = con.cursor()
        # not using row factory with the database api
        # notice getting GeomId,Id to easily feed into dictionary
        cur.execute("SELECT GeomId,Id FROM Calc WHERE CalcId=?",(CalcTypeId,))
        calcRow = cur.fetchall()

        # if len(calcRow)<totGeom:
        #     raise Exception("Not enough number of completed calculations present in database")

        # a set of geomIds that is already done
        CalcGeomIds = set([geomId for geomId,_ in calcRow ])
        DictCalcId  = dict(calcRow)

        # set of geomIds that will be excluded from exporting
        ExcludeGeomIds = CalcGeomIds.copy()

        if not bIncludePath:
            cur.execute("SELECT Id FROM Geometry WHERE tags LIKE '%path%'")
            ExcludeGeomIds.update(cur.fetchall())


        #! also adding the status, will trim the expcalc search heavily... Try to get geomids from expcalc
        # cur.execute("SELECT ID FROM Exports WHERE CalcType=?",(CalcTypeId,))
        cur.execute("SELECT ID FROM Exports WHERE status=0 CalcType=?",(CalcTypeId,))
        for expId in cur:
            cur.execute("SELECT GeomId FROM ExpCalc WHERE ExpId=?",(expId,))
                ExcludeGeomIds.update(cur.fetchall())


    #--------------------------------------------------------------------------------
            # lPrblmGeomIds = []
            # ExcludeGeomIds.update(lPrblmGeomIds)
    #--------------------------------------------------------------------------------

        DictStartId = {}
        GidListNew = []

        for g,s in itertools.izip_longest(GidList,SidList):
            if (g in ExcludeGeomIds) or (s==None):
                DictStartId[g] = -1
                GidListNew.append(0)    #<--- why adding geomlist here?
            else:
                DictStartId[g] = s
                GidListNew.append(geom)


        ########################### New style of neighbour searching ####################################
        sql = "select Id,Nbr form Geometry"
        if GidListNew and ConstDb :
            sql += "where id in (" + ",".join([str(i) for i in GidListNew]) + ") and (" + ConstDb + ")"
        elif GidListNew and not ConstDb:
            sql += "where id in (" + ",".join([str(i) for i in GidListNew]) + ")"
        elif not GidListNew and ConstDb:
            sql += "where "  + ConstDb
        cur.execute(sql)

        # this is only useful only if one gives jobs number less than the gid list length
        # if GidListNew: 
        #     # so when gid list given cur is simple list o/w cur is sqlite iterator. 
        #     # is this bad?,  the cur sqlite instance is not needed after this point
        #     cur = cur.fetchall() 
        #     totGeom = len(cur)

        ExpGeomIdList = []
        ExpCalcIdList = []

        # ExcludeGeomIds and CalcGeomIds are sets for faster searching
        for GeomId, nbrList in cur:
            if len(ExpGeomIdList)==totGeom: break

            # don't export if GeomId already inside exported list.. Though this should not have happened
            # if GeomId in ExpGeomIdList: continue
            
            if GeomId in ExcludeGeomIds: continue

            for depth, nId in enumerate(nbrList.split(), start=1):
                nId = int(nId)
                if not maxDepth and (depth>maxDepth): break 

                if GidListNew: # can I get some of this block out of this loop?
                    if DictStartId[GeomId] > 0:
                        NbrId = DictStartId[GeomId]
                    elif DictStartId[GeomId] < 0:
                        NbrId = nId
                    else:
                        NbrId = 0
                else: 
                    NbrId = nId

                if not NbrId:
                    ExpGeomIdList.append(GeomId)
                    ExpCalcIdList.append(0)
                    break

                if NbrId in CalcGeomIds:
                    ExpGeomIdList.append(GeomId)
                    ExpCalcIdList.append(DictCalcId[NbrId])
                    break # got one match now don't search for other neighbours


    # preventing null exports
    assert len(ExpGeomIdList), "Can't export any geometries"
    return zip(ExpGeomIdList, ExpCalcIdList)




def GetExpMrciNactJobs(Db,CalcTypeId,totGeom=50,constDb=""):
    """ Returns a list of geometries for MRCI or NACT calc- to be exported.
        A list of (GeomId,CalcId) is returned where
            GeomId : geometry to be exported
            CalcId : the id in calc table which corresponds to calc of calctypeid = 1 of the GeomId.
        This will return an empty list if it can not export.
    """

   with sqlite3.connect(Db) as con:
        cur = con.cursor()

        cur.execute("SELECT Id FROM Calc WHERE CalcId=?",(CalcTypeId,))
        CalcGeomIds = set(cur.fetchall())
        ExcludeGeomIds = CalcGeomIds.copy()

        cur.execute("SELECT ID FROM Exports WHERE status=0 CalcType=?",(CalcTypeId,))
        for expId in cur:
            cur.execute("SELECT GeomId FROM ExpCalc WHERE ExpId=?",(expId,))
                ExcludeGeomIds.update(cur.fetchall())

    #--------------------------------------------------------------------------------
            # lPrblmGeomIds = []
            # ExcludeGeomIds.update(lPrblmGeomIds)
    #--------------------------------------------------------------------------------

        # is this really needed, mrci and nact export rarely takes any constraint
        # and for that rare moment, We are adding thousands of database calls and set checks
        # sConst = " where " + constDb if constDb else ""
        # cur.execute("SELECT Id FROM Geometry" + sConst )
        # ConstGeomIds = set(cur.fetchall())                

        # ExpGeomIdList = []
        # ExpCalcIdList = []

        # cur.execute("SELECT Id,GeomId FROM Calc WHERE CalcId = 1")
        # for StartId, GeonId in cur:
        #     if GeomId not in ExcludeGeomIds and GeomId in ConstGeomIds:
        #         ExpGeomIdList.append(GeomId)
        #         ExpCalcIdList.append(StartId)
                
        #         if len(ExpGeomIdList)==totGeom: break

        # alternative of the above
        if constDb:
            cur.execute("SELECT Id FROM Geometry where " + constDb )
            ConstGeomIds = set(cur.fetchall())                

        ExpGeomIdList = []
        ExpCalcIdList = []

        cur.execute("SELECT Id,GeomId FROM Calc WHERE CalcId = 1")
        for StartId, GeonId in cur:
            if (GeomId not in ExcludeGeomIds) and constDb and (GeomId in ConstGeomIds):
                ExpGeomIdList.append(GeomId)
                ExpCalcIdList.append(StartId)
                
                if len(ExpGeomIdList)==totGeom: break


    # preventing null exports
    assert len(ExpGeomIdList), "Can't export any geometries"
    return zip(ExpGeomIdList, ExpCalcIdList)



def ExportGeometries(Args,ExportList,ExpDir):
   """ this exports a list of geometries to separate directories """


   ExportedDirs = []
   for (GeomId,StartCalcId,BaseSuffix) in ExportList:
      BaseName = ExportCalc(Args.DbMain,GeomId,Args.CalcTypeId,Args.PESDir,ExpDir,
                            ComTemplate=Args.ComTemplate,StartId=StartCalcId,
                            BaseSuffix=BaseSuffix,Verbose=Args.Verbose)
      # collect list of base names exported
      ExportedDirs.append(BaseName)

   return ExportedDirs




def ExportCalc(Db,GeomId,CalcTypeId,DataDir,ExpDir,ComTemplate="",StartId=0,BaseSuffix="",Verbose=False):

    with sqlite3.connect(Db) as con:

        # use row factory which is far better and has dictionary-like access to data
        con.row_factory = sqlite3.Row
        cur = con.cursor()

        # GeomId and CalcTypeId check
        cur.execute('SELECT * from Geometry WHERE Id=?',(GeomId,))
        GeomRow = cur.fetchone()
        cur.execute('SELECT * from CalcInfo WHERE Id=?',(CalcTypeId,))
        InfoRow= cur.fetchone()


        # This should never happend as it will get blocked inside the getnbr function
        # now on, we will make it an error to export something already present in Calc table
        # TODO: change this to allow some flexibility to repeat a calculation.
        # cur.execute('SELECT * from Calc WHERE GeomId=? AND CalcId=?',(GeomId,CalcTypeId))
        # if cur.fetchall():
            # non-zero records, this calculation already exists.
            # raise Exception("Error: The calculation of type CalcTypeId=%r on GeomId=%r already exists" % (CalcTypeId,GeomId))


        #! This depends checking block is also not needed here. 
        # In our case only the mrci and nact jobs depends on multi i.e. calcid 1, 
        # and we have already got the export list by checking calc table for multi before, 
        # so doing that again here is useless, but may be required for more complicated calculation
        
        # if the calculation is declared to be dependent on another calculation type
        # make sure the that calculation results are available on the data base.
        # otherwise no point in exporting -- is there a point doing mrci which depends on some multi
        # CalcTypeIdDep = InfoRow["Depends"] 
        # if CalcTypeIdDep:
        #     # check the CalcInfo table for details of this calculation type
        #     cur.execute("SELECT * from CalcInfo WHERE Id=?",(CalcTypeIdDep,))
        #     irow = cur.fetchall()
        #     if len(irow) == 1:
        #         # now check if there is calculation of this type on this geometry in Calc table
        #         cur.execute("SELECT * from Calc WHERE GeomId=? AND CalcId=?",(GeomId,CalcTypeIdDep))
        #         crow = cur.fetchall()
        #         if len(crow) == 0:
        #         # the calculation is not available, raise exeception
        #         raise Exception("This calculation depends on CalcId=%r which does not exist in Calc table" % (CalcTypeIdDep,))
        #         else:
        #         # there must be exactly one such calculation -- just to make sure
        #         assert(len(crow) == 1)
        #     else:
        #         # invalid CalcTypeIdDep provided -- this is error in config file supplied
        #         raise Exception("Invalid CalcId for Depends field -- check config file for this calc type")
        # now dependency conditions are met.

        # now prepare for generating the calc file
        # CalcName = InfoRow["Name"]
        if ComTemplate:
            with open(ComTemplate,'r') as f:
            InpTempl = f.read()
        else:
            InpTempl = InfoRow["InpTempl"]
        Record = InfoRow["OrbRec"]

        # if StartId is non-zero, then it must exist in Calc table.
        # we gather details necessary for setting up such input
        # we need:
        #    wfn file of calculation
        #    the record number of orbitals
        bUnzip = False
        if StartId:
            cur.execute('SELECT * from Calc WHERE Id=?',(StartId,))
            # start_row = cur.fetchall()  # this should always return one element, checked already before
            # assert (len(start_row) == 1)
            # StartCalcRow = start_row[0]
            StartCalcRow = cur.fetchone()
            # pickup details from here -- needed for completing template file
            StartGId = StartCalcRow["GeomId"]
            # StartDir = DataDir + "/" + StartCalcRow["Dir"]
            # StartWfnFile = StartCalcRow["WfnFile"]
            # StartRecord = StartCalcRow["OrbRec"]
            StartDir = DataDir + "/" + "geom{}/{}{}".format(GeomId, InfoRow["Type"], CalcTypeId)  # <-- so, not really needed from database
            StartWfnFile = StartDir + "/" + "{}{}-geom{}.wfu".format(InfoRow["Type"], CalcTypeId,GeomId) # <-- so, not really needed from database
            StartRecord = Record
            # check access for wave-function -- it could be a zip file
            misc.CheckDirAccess(StartDir,bRead=True,bAssert=True)
            if misc.CheckFileAccess(StartDir + "/" + StartWfnFile,bRead=True,bAssert=False):
                bUnzip = False
            elif misc.CheckFileAccess(StartDir + "/" + StartWfnFile + ".gz",bRead=True,bAssert=False):
                bUnzip = True
            else:
                raise Exception("Wavefunction file=%r does not exist" %(StartWfnFile,))
        # else:
        #     StartGId = 0


        # decide basename needed for generated files
        # we can use a combination of geometry and calculation name to be sure
        # basename = CalcType + CalcId + "-" + "geom" + GeomId
        # this works out something like "multi2-geom1" .. should be fine I think.
        # TODO: do this optimally if these turn out to be too difficult to navigate.
        BaseName = InfoRow["Type"] + str(CalcTypeId) + "-" + "geom" + str(GeomId)
        if BaseSuffix:
            BaseName = BaseName + "-" + BaseSuffix

        # create required directory
        ExportDir = ExpDir + "/" + BaseName
        os.makedirs(ExportDir,0775)

        # now we are ready to generate files, first calc and xyz files
        sCalcFile = GenCalcFile(CalcTypeId,GeomId,CalcName,Record,BaseName,Desc="",Aux="Start GId - " + str(StartGId))
        #! This is bad, something so inside of a library mustn't be hardcoded outside dependencies
        #! get this out of here immediately
        GeomObj = geometry.Geometry(GeomRow["sr"],GeomRow["cr"],GeomRow["theta"],id=GeomId)
        #! also make the xyz file outside
        sXYZFile = GeomObj.to_xyzstr()

        # write them out
        # for calc file, we will generate it as .calc_ <--- note extra underscore at end
        # this is to safegaurd against faulty imports.
        # this should be renamed to .calc upon successful run
        fCalc = ExportDir + "/" + BaseName + ".calc_"  # <-- extra underscore
        fXYZ  = ExportDir + "/" + BaseName + ".xyz"
        with open(fCalc,'w') as f: f.write(sCalcFile)
        with open(fXYZ,'w')  as f: f.write(sXYZFile)

        # if wfn file needs to be copied from elsewhere, do that now
        if StartId:
            fSrcWfn = StartDir + "/" + StartWfnFile # this has .wfu extension already
            fDstWfn = ExportDir + "/" + BaseName + ".wfu"
            if bUnzip:
                fSrcWfn += ".gz"
                fDstWfn += ".gz"
            shutil.copy(fSrcWfn,fDstWfn)
            if bUnzip:
                subprocess.call(["gzip", "-d", fDstWfn])
                
        # now input file -- apply replacement substitutions to template string
        s0 = InpTempl.replace("$F$",BaseName)
        s1 = s0.replace("$R$",Record)
        # $S$ may not exist in all files
        if s1.count("$S$"):
            # substitute with starting record if asked for
            if StartId:
                sInpFile = s1.replace("$S$",StartRecord)
            else:
                sInpFile = s1
                print "WARNING: template not fully substituted -- check input file"
        else:
            sInpFile = s1
        # generate input file
        fInp = ExportDir + "/" + BaseName + ".com" # we have decided to generate .com and not .inp
        with open(fInp,'w') as f:
            f.write(sInpFile)
