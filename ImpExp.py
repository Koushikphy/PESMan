from __future__ import print_function
import re
import os
import shutil
import tarfile
import sqlite3 
from itertools import izip_longest
from glob import glob
from geometry import geomObj
# initiate the geometry object inside the geometry file  and call the methods from there
# this is benificial for normal mode as the code doesn't have to initite the object for every geometry




def parseResult(file):
    # Collects any valid number and returns the result as a string
    with open(file, 'r') as f:
        txt = f.read()
    txt = txt.replace('D','E')
    res = re.findall(r"(?:(?<=^)|(?<=\s))([+-]?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)(?=\s|$|\n|\r\n)", txt)
    return ' '.join(res)


def genCalcFile(CalcId,GeomId,CalcName,Basename,sid,fileName,Desc=""):
    # Creates the calc files 
    txt = """# This file is automatically generated.Do not edit, unless you are sure of what you are changing.
    CalcId   : {}
    GeomId   : {}
    Name     : {}
    Basename : {}
    StartGId : {}
    Desc     : {}""".format(CalcId,GeomId,CalcName,Basename,sid,Desc)

    with open(fileName, "w") as f:
        f.write(txt)



def ExportNearNbrJobs(dB, calcId, jobs, exportDir,pesDir, templ, gidList, sidList, depth, constDb, includePath, molInfo):
    # Main export function that exports a given number of jobs for a specified calcid type
    # collect the geomid that are exportable and the calc table id which will be used as their startid
    if calcId > 1: # Mrci or nact export
        ExpGeomList = GetExpMrciNactJobs(dB,calcId, jobs, constDb)
    else:
        ExpGeomList = GetExpGeomNearNbr(dB,calcId, gidList, sidList, jobs, depth, constDb, includePath)


    # The context manager prevents the database from commiting in case of error, use try-except for further control
    with sqlite3.connect(dB) as con:
            con.row_factory=sqlite3.Row
            cur = con.cursor()
            cur.execute('SELECT * from CalcInfo WHERE Id=?',(calcId,))
            InfoRow = cur.fetchone()
            assert InfoRow, "No Info found for CalcId={} found in data base".format(calcId)
            # insert into database one row and use the id as export id
            cur.execute("INSERT INTO Exports (CalcId) VALUES (?)", (calcId,))
            exportId = cur.lastrowid

            ExpDir = "{}/Export{}-{}{}".format(exportDir, exportId, InfoRow["type"], calcId)
            # remove the export directory if already exists, may have created from some failed export. should'nt happened
            if os.path.exists(ExpDir): 
                shutil.rmtree(ExpDir)
            os.makedirs(ExpDir)

            expDirs = []
            for ind, (GeomId,StartCalcId) in enumerate(ExpGeomList, start=1):
                print('Exporting Job No {} with GeomId {}'.format(ind, GeomId))
                bName = ExportCalc(cur, dB, GeomId, calcId,pesDir,ExpDir, InfoRow, templ,StartId=StartCalcId, BaseSuffix=str(ind))
                expDirs.append(bName)


            # update the export table and expcalc tables with the exported jobs
            cur.execute("UPDATE Exports SET NumCalc=?, ExpDT=strftime('%H:%M:%S %d-%m-%Y', datetime('now', 'localtime')) WHERE Id=?", (len(expDirs),exportId))

            lExpCalc = [[exportId,calcId, ExpGeomList[i][0]] for i in range(len(expDirs))]
            cur.executemany("INSERT INTO ExpCalc (ExpId,CalcId,GeomId) VALUES (?,?,?)",lExpCalc)

            # save the export id and exported directories in export.dat file
            fExportDat = ExpDir + "/export.dat"
            with open(fExportDat,'w') as f:
                f.write("# Auto generated file. Please do not modify\n"+ ' '.join(map(str,[exportId]+expDirs)))

            # change mode of this file to read-only to prevent accidental writes
            os.chmod(fExportDat,0444)

            # save the python file that will run the jobs
            fPythonFile =   "{}/RunJob{}.py".format(ExpDir, exportId)
            createRunJob(molInfo, fPythonFile)
            # shutil.copy("RunJob.py", fPythonFile)
            # os.chmod(fPythonFile,0766)
            print("PESMan export successful: Id {} with {} job(s) exported".format(exportId, len(ExpGeomList)))
            return ExpDir, exportId, expDirs



def GetExpGeomNearNbr(dB,calcId,GidList=[],SidList=[],jobs=1,maxDepth=0,ConstDb="",inclPath=False):
    # Get the exportable geometries and their start id for mulit jobs, returns 
    with sqlite3.connect(dB) as con:
        cur = con.cursor()
        
        # get jobs that is already done
        cur.execute("SELECT GeomId,Id FROM Calc WHERE CalcId=?",(calcId,))
        calcRow = cur.fetchall()
        CalcGeomIds = set([geomId for geomId,_ in calcRow ])
        DictCalcId  = dict(calcRow)
        # set of geomIds that will be excluded from exporting
        ExcludeGeomIds = CalcGeomIds.copy()

        if not inclPath: # don't pathological points
            cur.execute("SELECT Id FROM Geometry WHERE tags LIKE '%path%'")
            ExcludeGeomIds.update([i[0] for i in cur.fetchall()])

        # collect jobs that is exported but not imported, they are mot exportable
        # cur.execute("SELECT ID FROM Exports WHERE Status=0 and CalcId=?",(calcId,))
        # ids = cur.fetchall()
        # for expId in ids:
        #     cur.execute("SELECT GeomId FROM ExpCalc WHERE ExpId=?",expId) #<-- expid already a tuple,returns a list of tuples, onelist for one filed i.e. GeomId
        #     ExcludeGeomIds.update([i[0] for i in cur.fetchall()]) 
        
        cur.execute("SELECT GeomId FROM ExpCalc WHERE CalcId=?",(calcId,))
        ExcludeGeomIds.update([i[0] for i in cur])

    #--------------------------------------------------------------------------------
        # lPrblmGeomIds = []
        # ExcludeGeomIds.update(lPrblmGeomIds)
    #--------------------------------------------------------------------------------

        DictStartId = {}
        GidListNew = []
        # in case some start geomids are provided. if gid is there but not sid then save start id as -1
        for g,s in izip_longest(GidList,SidList):
            if s==None: s=-1
            DictStartId[g] = s
            if g in ExcludeGeomIds:
                GidListNew.append(0)  
            else:
                GidListNew.append(g)


        sql = "SELECT Id,Nbr FROM Geometry "
        if GidListNew and ConstDb :
            sql += "where id in (" + ",".join([str(i) for i in GidListNew]) + ") and (" + ConstDb + ")"
        elif GidListNew and not ConstDb:
            sql += "where id in (" + ",".join([str(i) for i in GidListNew]) + ")"
        elif not GidListNew and ConstDb:
            sql += "where "  + ConstDb
        cur.execute(sql)
        print(sql)

        cond = []
        if GidListNew:   cond.append( 'id in (' + ",".join(map(str, GidListNew)) + ')')  #include gidlist
        if ConstDb:      cond.append( '(' + ConstDb + ')')                               #include constraint
        if not inclPath: cond.append( "tags NOT LIKE '%path%'")                          #exclude pathological

        cond = ' where ' + ' and '.join(cond) if cond else ''
        sql = 'SELECT Id,Nbr FROM Geometry' + cond
        print(sql)


        expGClist = []   # list that collects the exportable jobs info
        fullGeomList = []   # a naive approach: store all the missed geometries
        for GeomId, nbrList in cur:
            if GeomId in ExcludeGeomIds: continue                 # geometry already exist, skip
            if GidListNew and DictStartId[GeomId]>=0:             # negetive start id will go to main neighbour searching loop
                NbrId = DictStartId[GeomId]                       # i.e. 0 or positive startid given
                if not NbrId :                                    # 0 startid nothing to do here
                    expGClist.append([GeomId, 0])
                elif NbrId in CalcGeomIds :                       # positive start id, include if calculation is already done
                    expGClist.append([GeomId, DictCalcId[NbrId]])
                if len(expGClist)==jobs: 
                    return expGClist         # got all the geometries needed
                continue

            nbrList = map(int, nbrList.split())                   # Care ful about integer mapping
            NbrId = nbrList[0]                                    # for this initial loop only consider first neighbour

            if NbrId in CalcGeomIds:
                expGClist.append([GeomId, DictCalcId[NbrId]])     # got one match 
                if len(expGClist)==jobs:
                    return expGClist
                continue
            fullGeomList.append([GeomId, nbrList])
        
        # handle 0 depth properly, this is poor
        depth = maxDepth if maxDepth else len(fullGeomList[0][1]) if fullGeomList else 0  
        exportedGeom = set([])
        for d in range(1,depth):                                   # depth loop starting from 1 to end, 
            for GeomId, nbrList in fullGeomList:
                if GeomId in exportedGeom: continue

                NbrId = nbrList[d]                                # get d-th neighbour
                if NbrId in CalcGeomIds:
                    expGClist.append([GeomId, DictCalcId[NbrId]])  # got one match now don't search for any other neighbours
                    if len(expGClist)==jobs:     
                        return expGClist
                    exportedGeom.add(GeomId)


    # preventing null exports
    assert len(expGClist), "No Exportable geometries found"
    return expGClist





def GetExpMrciNactJobs(dB,calcId,jobs=50,ConstDb=""):


    with sqlite3.connect(dB) as con:
            cur = con.cursor()

            cur.execute("SELECT GeomId FROM Calc WHERE CalcId=?",(calcId,))
            CalcGeomIds = set(cur.fetchall())
            ExcludeGeomIds = CalcGeomIds.copy()  # jobs that is already done.

            # cur.execute("SELECT ID FROM Exports WHERE Status=0 and CalcId=?",(calcId,))
            # ids = cur.fetchall()
            # for expId in ids:
            #     cur.execute("SELECT GeomId FROM ExpCalc WHERE ExpId=?",expId) #<-- expid already a tuple returns a list of tuples, onelist for one filed i.e. GeomId
            #     ExcludeGeomIds.update([i[0] for i in cur.fetchall()]) 

            cur.execute("SELECT GeomId FROM ExpCalc WHERE CalcId=?",(calcId,))
            ExcludeGeomIds.update([i[0] for i in cur])
        #--------------------------------------------------------------------------------
            # lPrblmGeomIds = []
            # ExcludeGeomIds.update(lPrblmGeomIds)
        #--------------------------------------------------------------------------------
            if ConstDb:
                cur.execute("SELECT Id FROM Geometry where " + ConstDb )
                ConstGeomIds = set([i[0] for i in cur.fetchall()])

            cur.execute("SELECT Id,GeomId FROM Calc WHERE CalcId = 1")

            expGClist = []
            for StartId, GeomId in cur:
                if ConstDb and (GeomId not in ConstGeomIds): # this is a small list so checking it before excludelist
                    continue
                if (GeomId not in ExcludeGeomIds):
                    expGClist.append([GeomId, StartId])
                    if len(expGClist)==jobs: # got everything needed
                        break

    # preventing null exports
    assert len(expGClist), "No Exportable geometries found"
    return expGClist





def ExportCalc(cur, Db,GeomId,calcId,DataDir,ExpDir, InfoRow, ComTemplate="",StartId=0,BaseSuffix=""):


    # GeomId and CalcId check
    cur.execute('SELECT * from Geometry WHERE Id=?',(GeomId,))
    GeomRow = cur.fetchone()

    # if template given use that, o/w use from calcinfo table
    if ComTemplate:
        with open(ComTemplate,'r') as f:  InpTempl = f.read()
    else:
        InpTempl = InfoRow["InpTempl"]

    # if StartId is non-zero, then collect necessary things from calc table
    if StartId:
        cur.execute('SELECT * from Calc WHERE Id=?',(StartId,))
        calcRow = cur.fetchone()
        StartGId = calcRow["GeomId"]
        StartDir = calcRow["Dir"]
        c,a,b = StartDir.split("/") # StartDir -> GeomData/geom1/multi1; StartBaseName -> multi1-geom1
        StartBaseName = "{}-{}".format(b,a)
    else:
        StartGId = 0


    # decide basename needed for generated files and create the main export directory
    BaseName = "{}{}-geom{}-".format(InfoRow["Type"], calcId, GeomId) + BaseSuffix
    ExportDir = ExpDir + "/" + BaseName
    os.makedirs(ExportDir)


    # for calc file, we will generate it as .calc_ <--- note extra underscore at end
    # this is to safegaurd against faulty imports.
    # this should be renamed to .calc upon successful run
    fCalc = ExportDir + "/" + BaseName + ".calc_"  # <-- extra underscore
    fXYZ  = ExportDir + "/" + BaseName + ".xyz"
    genCalcFile(CalcId,GeomId,InfoRow["Type"],BaseName,StartGId,fCalc)
    geomObj.createXYZfile(GeomRow, filename = fXYZ)  #< -- geometry file is created from outside



    # if wfn file needs to be copied from elsewhere, do that now
    if StartId:
        if os.path.isdir(StartDir): # not in zipped format, copy it to a new name
            shutil.copy(StartDir+ "/%s.wfu"%StartBaseName, ExportDir+"/%s.wfu"%BaseName )
        else: # file is in tar
            tar = tarfile.open(StartDir+".tar.bz2")
            tar.extract("./%s.wfu"%StartBaseName, path=ExportDir) # open tar file and rename it
            os.rename(ExportDir+"/%s.wfu"%StartBaseName, ExportDir+"/%s.wfu"%BaseName)

    txt = InpTempl.replace("$F$",BaseName)
    # generate input file
    fInp = ExportDir + "/" + BaseName + ".com" 
    with open(fInp,'w') as f: f.write(txt)

    return BaseName









def ImportNearNbrJobs(dB, expFile, DataDir, iGl, isDel, isZipped):
    # imports jobs from a givrn export.dat file

    ExportDir = os.path.abspath(os.path.dirname(expFile))

    with open(expFile,'r') as f: # read the export.dat and collect export id and director list
        dat = f.read().split("\n",1)[1].split(" ") #skip first line
        exportId, calcDirs = dat[0], dat[1:]

    # only consider the folder that has a `.calc` file
    calcDirsDone = set([d for d in calcDirs if os.path.isfile("{0}/{1}/{1}.calc".format(ExportDir, d)) ])

    with sqlite3.connect(dB) as con:
            cur = con.cursor()
            cur.execute('SELECT Status FROM Exports WHERE Id=?',(exportId,))         # check if the export id is ready for export
            exp_row = cur.fetchone()
            assert exp_row,        "Export Id = {} not found in data base".format(exportId)
            assert exp_row[0] ==0, "Export Id = {} is already closed.".format(exportId)

            # now obtain list of jobs which can be imported.
            cur.execute("SELECT GeomId,CalcDir FROM ExpCalc where ExpId=?",(exportId,))
            toImportList = cur.fetchall()
            importCount = 0
            for geomId, calcDir in toImportList:
                if calcDir in calcDirsDone:

                    dirFull = ExportDir + "/" + calcDir
                    cFiles = glob(dirFull+"/*.calc")
                    # assert len(cFiles)==1, "{} must have 1 calc file but has {}.".format(dirFull, len(cFiles))

                    print("Importing ...{}... ".format(dirFull), end='')
                    ImportCalc(cur,dirFull,cFiles[0],DataDir, ignoreList=iGl, zipped=isZipped)
                    print("done")

                    cur.execute('DELETE FROM ExpCalc WHERE ExpId=? AND GeomId=? ',(exportId,geomId))
                    importCount += 1
                    
                    if isDel: 
                        print("Deleting directory {}".format(dirFull))
                        shutil.rmtree(dirFull)

            sImpGeomIds =''# update what geometries are imported with this exportid, to be handled later
            cur.execute("UPDATE Exports SET ImpDT=strftime('%H:%M:%S %d-%m-%Y', datetime('now', 'localtime')), ImpGeomIds=? WHERE Id=?",(sImpGeomIds,exportId))


            cur.execute("SELECT count(*) FROM ExpCalc WHERE ExpId=?",(exportId,))

            if cur.fetchone()[0]==0:
                cur.execute("UPDATE Exports SET Status=1 WHERE Id=?",(exportId,))
                print('Export Id={} is now closed.'.format(exportId))
                if isDel: shutil.rmtree(ExportDir)
            else :
                print('Export Id={} is not closed.'.format(exportId))

            print("{} Job(s) have been successfully imported.".format(importCount))





def ImportCalc(cur,CalcDir,CalcFile,DataDir,ignoreList, zipped):

    with open(CalcFile,'r') as f:
        txt = f.read().split("\n")[1:] #first line comment
    dCalc = dict([map(str.strip, i.split(":")) for i in txt])

    a,b,_ = dCalc['Basename'].split('-') # a base name `multinact2-geom111-1` will go `GeomData/geom111/multinact2`
    DestCalcDir = DataDir+"/{}/{}".format(b,a)
    fRes = "{}/{}.res".format(CalcDir, dCalc['Basename'])
    sResults = parseResult(fRes)
    if not os.path.exists(DestCalcDir):  os.makedirs(DestCalcDir)

    tcalc = (dCalc["GeomId"],dCalc["CalcId"], DestCalcDir, dCalc["StartGId"],sResults)
    cur.execute("INSERT INTO Calc (GeomId,CalcId,Dir,StartGId,Results) VALUES (?, ?, ?, ?, ?)", tcalc)

    for iFile in glob("{}/*.*".format(CalcDir)):
        if os.path.splitext(iFile)[1] in ignoreList:  # copy all file except for ignore list
            continue
        oFile = DestCalcDir + "/" + re.sub('-\d+','',os.path.basename(iFile)) 
        shutil.copy(iFile, oFile)
    if zipped:
        shutil.make_archive(DestCalcDir, 'bztar', root_dir=DestCalcDir, base_dir='./')
        shutil.rmtree(DestCalcDir)




def createRunJob(molInfo, file):
    
    txt = '''#!/usr/bin/python
# -*- coding: utf-8 -*-

import os
import subprocess
from datetime import datetime


def writeLog(fLog, msg, cont=False): # writes to the log file
    if not cont : 
        msg = '{{:.<90}}'.format(datetime.now().strftime("[%d-%m-%Y %I:%M:%S %p]     ") + msg)
    else:
        msg+='\\n'
    fLog.write(msg)
    fLog.flush()


def runExportedCalcs(scrDir, proc, extra):
    """ Run or continue a series of exported jobs."""

    # first open export.dat file and collect information about exported jobs
    with open("export.dat",'r') as f:
        sExpDat = f.read().split("\\n",1)[1]

    # obtain a list of incomplete jobs
    # such jobs will not have corresponding .calc file, but .calc_ file
    CalcDirs = sExpDat.split()
    DirsDone = [d for d in CalcDirs if os.path.isfile(d+"/"+d+".calc")]
    DirsToDo = [d for d in CalcDirs if os.path.isfile(d+"/"+d+".calc_")]
    mainDirectory = os.getcwd()

    #    if len(CalcDirs) != len(DirsDone) + len(DirsToDo):
    #       raise Exception("Some dirs in this export directory = " + os.getcwd() + " seem to not have .calc/.calc_ file.")

    fLog = open("run.log","a")
    if len(DirsDone):
        txt = "Skipping already compelted job Dir: \\n" + '\\n'.join(DirsDone)
        writeLog(fLog, txt, True)

    # now execute each job
    for RunDir in DirsToDo:
        writeLog(fLog, "Running Job for "+RunDir)

        fComBaseFile = RunDir + ".com"

        os.chdir(RunDir)

        exitcode = subprocess.call(["molpro", "-d", scrDir, "-W .", "-n", proc, fComBaseFile] + extra)
        os.chdir(mainDirectory)

        if exitcode == 0:
            writeLog(fLog, "Job Successful.", True)
            os.rename( "{{0}}/{{0}}.calc_".format(RunDir), "{{0}}/{{0}}.calc".format(RunDir))    # rename .calc_ file so that it can be imported

        else:
            writeLog(fLog, "Job Failed.", True)

    writeLog(fLog, "All Jobs Completed\\n")
    writeLog(fLog, "."*70, True)
    fLog.close()



def dummyRun(scrDir, proc, extra):
    """ Used only for debugging purpose"""

    with open("export.dat",'r') as f:
        sExpDat = f.read().split("\\n",1)[1]
    DirsToDo = [d for d in sExpDat.split() if os.path.isfile(d+"/"+d+".calc_")]
    for RunDir in DirsToDo:
        fComBaseFile = RunDir + ".com"
        with cd(RunDir):
            with open("%s.wfu"%RunDir, "w") as f: f.write("Nothing to see here")
            with open("%s.res"%RunDir, "w") as f: f.write("21 111 73")
            os.rename( "%s.calc_"%RunDir, "%s.calc"%RunDir)




if __name__ == '__main__':

    scrDir = {}
    proc   = str({})
    extra  = {}

    runExportedCalcs(scrDir, proc, extra)
    # dummyRun(scrDir, proc, extra)

'''.format(molInfo['scrdir'], molInfo['proc'], molInfo['extra'])
    with open(file, 'w') as f:
        f.write(txt)
    os.chmod(file,0766)