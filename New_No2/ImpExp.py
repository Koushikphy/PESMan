from __future__ import print_function
import re
import os
import sys
import shutil
import tarfile
import sqlite3 
import itertools
import numpy as np 
from glob import glob
from geometry import geomObj
# initiate the geometry object inside the geometry file  and call the methods from there
# this is benificial for normal mode as the code doesn't have to initite the object for every geometry




def parseResult(file):
    # Collects any valid number and returns the result as a string
    with open(file, 'r') as f:
        txt = f.read()
    txt = txt.replace('D','E')
    res = re.findall(r"(?:(?<=^)|(?<=\s))([+-]?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)(?=\s|$|\n|\r\n)", txt)
    return ' '.join(res)


def genCalcFile(CalcId,GeomId,CalcName,Basename,sid,fileName,Desc=""):
    # Creates the calc files 
    txt = """# This file is automatically generated.Do not edit, unless you are sure of what you are changing.
    CalcId   : {}
    GeomId   : {}
    Name     : {}
    Basename : {}
    StartGId : {}
    Desc     : {}""".format(CalcId,GeomId,CalcName,Basename,sid,Desc)

    with open(fileName, "w") as f:
        f.write(txt)



def ExportNearNbrJobs(dB, calcTypeId, jobs, exportDir,pesDir, templ, gidList, sidList, depth, constDb, includePath):
    # Main export function that exports a given number of jobs for a specified calcid type
    # collect the geomid that are exportable and the calc table id which will be used as their startid
    if calcTypeId > 1: # Mrci or nact export
        ExpGeomList = GetExpMrciNactJobs(dB,calcTypeId, jobs, constDb)
    else:
        ExpGeomList = GetExpGeomNearNbr(dB,calcTypeId, gidList, sidList, jobs, depth, constDb, includePath)


    # The context manager prevents the database from commiting in case of error, use try-except for further control
    # try:
    with sqlite3.connect(dB) as con:
            con.row_factory=sqlite3.Row
            cur = con.cursor()
            cur.execute('SELECT * from CalcInfo WHERE Id=?',(calcTypeId,))
            InfoRow = cur.fetchone()
            assert InfoRow, "No Info found for CalcType={} found in data base".format(calcTypeId)
            cur.execute("INSERT INTO Exports (Type,CalcType) VALUES (?,?)", (0,calcTypeId))
            exportId = cur.lastrowid

            ExpDir = "{}/Export{}-{}{}".format(exportDir, exportId, InfoRow["type"], calcTypeId)
            if os.path.exists(ExpDir): # remove the export directory if already exists, may have created from some failed export.
                shutil.rmtree(ExpDir)
            os.makedirs(ExpDir)

            expDirs = []
            for ind, (GeomId,StartCalcId) in enumerate(ExpGeomList, start=1):
                bName = ExportCalc(cur, dB, GeomId, calcTypeId,pesDir,ExpDir, InfoRow, templ,StartId=StartCalcId, BaseSuffix=str(ind))
                expDirs.append(bName)


            # udate the export table and expcalc tables with the exported jobs
            cur.execute("UPDATE Exports SET NumCalc=?, ExpDir=?, ExpDT=datetime('now','localtime') WHERE Id=?", (len(expDirs),ExpDir,exportId))

            lExpCalc = [[exportId, ExpGeomList[i][0], expDirs[i]] for i in range(len(expDirs))]
            cur.executemany("INSERT INTO ExpCalc (ExpId,GeomId,CalcDir) VALUES (?,?,?)",lExpCalc)

            # save the export id and exported directories in export.dat file
            fExportDat = ExpDir + "/export.dat"
            with open(fExportDat,'w') as f:
                f.write("# Auto generated file. Please do not modify\n"+ ' '.join(map(str,[exportId]+expDirs)))

            # change mode of this file to read-only to prevent accidental writes
            os.chmod(fExportDat,0444)

            # save the python file that will run the jobs
            fPythonFile =   "{}/RunJob{}.py".format(ExpDir, exportId)
            shutil.copy("RunJob.py", fPythonFile)
            os.chmod(fPythonFile,0766)
            print("PESMan export successful: Id {} with {} job(s) exported".format(exportId, len(ExpGeomList)))
    # except Exception as e:
    #     print("Can't export. {}: {}".format(type(e).__name__, e))




def GetExpGeomNearNbr(dB,CalcTypeId,GidList=[],SidList=[],jobs=1,maxDepth=0,ConstDb="",bIncludePath=False):
    # Get the exportable geometries and their start id for mulit jobs, returns 

    # try:
    with sqlite3.connect(dB) as con:
            cur = con.cursor()
            
            # get jobs that is already done
            cur.execute("SELECT GeomId,Id FROM Calc WHERE CalcId=?",(CalcTypeId,))
            calcRow = cur.fetchall()
            CalcGeomIds = set([geomId for geomId,_ in calcRow ])
            DictCalcId  = dict(calcRow)

            # set of geomIds that will be excluded from exporting
            ExcludeGeomIds = CalcGeomIds.copy()

            if not bIncludePath: # include pathological points
                cur.execute("SELECT Id FROM Geometry WHERE tags LIKE '%path%'")
                ExcludeGeomIds.update([i[0] for i in cur.fetchall()])

            # collect jobs that is exported but not imported, they are mot exportable
            cur.execute("SELECT ID FROM Exports WHERE Status=0 and CalcType=?",(CalcTypeId,))
            ids = cur.fetchall()
            for expId in ids:
                cur.execute("SELECT GeomId FROM ExpCalc WHERE ExpId=?",expId) #<-- expid already a tuple,returns a list of tuples, onelist for one filed i.e. GeomId
                ExcludeGeomIds.update([i[0] for i in cur.fetchall()]) 

        #--------------------------------------------------------------------------------
            # lPrblmGeomIds = []
            # ExcludeGeomIds.update(lPrblmGeomIds)
        #--------------------------------------------------------------------------------

            DictStartId = {}
            GidListNew = []

            # in case some start geomids are provided. if gid is there but not sid then save start id as -1
            for g,s in itertools.izip_longest(GidList,SidList):
                if s==None: s=-1
                DictStartId[g] = s
                if g in ExcludeGeomIds:
                    GidListNew.append(0)  
                else:
                    GidListNew.append(g)


            sql = "SELECT Id,Nbr FROM Geometry "
            if GidListNew and ConstDb :
                sql += "where id in (" + ",".join([str(i) for i in GidListNew]) + ") and (" + ConstDb + ")"
            elif GidListNew and not ConstDb:
                sql += "where id in (" + ",".join([str(i) for i in GidListNew]) + ")"
            elif not GidListNew and ConstDb:
                sql += "where "  + ConstDb
            cur.execute(sql)


            expGClist = []   # list that collects the exportable jobs info
            for GeomId, nbrList in cur:
                if GeomId in ExcludeGeomIds: continue     # geometry already exist, skip

                if GidListNew and DictStartId[GeomId]>=0: # negetive start id will go to main neighbour searching loop
                    NbrId = DictStartId[GeomId]           # i.e. 0 or positive startid given
                    if not NbrId :                        # 0 startid nothing to do here
                        expGClist.append([GeomId, 0])
                    elif NbrId in CalcGeomIds :           # positive start id, include if calculation is already done
                        expGClist.append([GeomId, DictCalcId[NbrId]])
                    continue

                for depth, nId in enumerate(nbrList.split(), start=1): # main neighbour searching loop
                    NbrId = int(nId)
                    if maxDepth and (depth>maxDepth): break# neighbour crossed maximum allowed depth

                    if NbrId in CalcGeomIds:
                        expGClist.append([GeomId, DictCalcId[NbrId]])
                        break # got one match now don't search for any other neighbours

                if len(expGClist)==jobs:     break         # got all the geometries needed

        # preventing null exports
    assert len(expGClist), "No exportable geometries found"
    return expGClist
    # except Exception as e:
    #     print("Can't export. {}: {}".format(type(e).__name__, e))





def GetExpMrciNactJobs(dB,CalcTypeId,jobs=50,ConstDb=""):

    # try:
    with sqlite3.connect(dB) as con:
            cur = con.cursor()

            cur.execute("SELECT GeomId FROM Calc WHERE CalcId=?",(CalcTypeId,))
            CalcGeomIds = set(cur.fetchall())
            ExcludeGeomIds = CalcGeomIds.copy()  # jobs that is already done.

            cur.execute("SELECT ID FROM Exports WHERE Status=0 and CalcType=?",(CalcTypeId,))
            ids = cur.fetchall()
            for expId in ids:
                cur.execute("SELECT GeomId FROM ExpCalc WHERE ExpId=?",expId) #<-- expid already a tuple returns a list of tuples, onelist for one filed i.e. GeomId
                ExcludeGeomIds.update([i[0] for i in cur.fetchall()]) 

        #--------------------------------------------------------------------------------
            # lPrblmGeomIds = []
            # ExcludeGeomIds.update(lPrblmGeomIds)
        #--------------------------------------------------------------------------------
            if ConstDb:
                cur.execute("SELECT Id FROM Geometry where " + ConstDb )
                ConstGeomIds = set([i[0] for i in cur.fetchall()])

            cur.execute("SELECT Id,GeomId FROM Calc WHERE CalcId = 1")

            expGClist = []
            for StartId, GeomId in cur:
                if ConstDb and (GeomId not in ConstGeomIds): # this is a small list so checking it before excludelist
                    continue
                if (GeomId not in ExcludeGeomIds):
                    expGClist.append([GeomId, StartId])
                    if len(expGClist)==jobs: # got everything needed
                        break

    # preventing null exports
    assert len(expGClist), "No exportable geometries found"
    return expGClist
    # except Exception as e:
    #     print("Can't export. {}: {}".format(type(e).__name__, e))




def ExportCalc(cur, Db,GeomId,CalcTypeId,DataDir,ExpDir, InfoRow, ComTemplate="",StartId=0,BaseSuffix=""):


    # GeomId and CalcTypeId check
    cur.execute('SELECT * from Geometry WHERE Id=?',(GeomId,))
    GeomRow = cur.fetchone()

    # if template given use that, o/w use from calcinfo table
    if ComTemplate:
        with open(ComTemplate,'r') as f:  InpTempl = f.read()
    else:
        InpTempl = InfoRow["InpTempl"]

    # if StartId is non-zero, then collect necessary things from calc table
    if StartId:
        cur.execute('SELECT * from Calc WHERE Id=?',(StartId,))
        calcRow = cur.fetchone()
        StartGId = calcRow["GeomId"]
        StartDir = calcRow["Dir"]
        c,a,b = StartDir.split("/") # StartDir -> GeomData/geom1/multi1; StartBaseName -> multi1-geom1
        StartBaseName = "{}-{}".format(b,a)
    else:
        StartGId = 0


    # decide basename needed for generated files and create the main export directory
    BaseName = "{}{}-geom{}-".format(InfoRow["Type"], CalcTypeId, GeomId) + BaseSuffix
    ExportDir = ExpDir + "/" + BaseName
    os.makedirs(ExportDir)


    # for calc file, we will generate it as .calc_ <--- note extra underscore at end
    # this is to safegaurd against faulty imports.
    # this should be renamed to .calc upon successful run
    fCalc = ExportDir + "/" + BaseName + ".calc_"  # <-- extra underscore
    fXYZ  = ExportDir + "/" + BaseName + ".xyz"
    genCalcFile(CalcTypeId,GeomId,InfoRow["Type"],BaseName,StartGId,fCalc)
    geomObj.createXYZfile(GeomRow, filename = fXYZ)  #< -- geometry file is created from outside



    # if wfn file needs to be copied from elsewhere, do that now
    if StartId:
        if os.path.isdir(StartDir): # not in zipped format, copy it to a new name
            shutil.copy(StartDir+ "/%s.wfu"%StartBaseName, ExportDir+"/%s.wfu"%BaseName )
        else: # file is in tar
            tar = tarfile.open(StartDir+".tar.bz2")
            tar.extract("./%s.wfu"%StartBaseName, path=ExportDir) # open tar file and rename it
            os.rename(ExportDir+"/%s.wfu"%StartBaseName, ExportDir+"/%s.wfu"%BaseName)

    txt = InpTempl.replace("$F$",BaseName)
    # generate input file
    fInp = ExportDir + "/" + BaseName + ".com" 
    with open(fInp,'w') as f: f.write(txt)

    return BaseName




def ImportNearNbrJobs(dB, expFile, DataDir, iGl, isDel, isZipped):
    # imports jobs from a given export.dat file

    ExportDir = os.path.abspath(os.path.dirname(expFile))

    with open(expFile,'r') as f: # read the export.dat and collect export id and director list
        dat = f.read().split("\n",1)[1].split(" ") #skip first line
        exportId, calcDirs = dat[0], dat[1:]

    # only consider the folder that has a `.calc` file
    calcDirsDone = set([d for d in calcDirs if os.path.isfile("{0}/{1}/{1}.calc".format(ExportDir, d)) ])
    # try:
    with sqlite3.connect(dB) as con:
            cur = con.cursor()
            cur.execute('SELECT Status FROM Exports WHERE Id=?',(exportId,))         # check if the export id is ready for export
            exp_row = cur.fetchone()
            assert exp_row,        "Export Id = {} not found in data base".format(exportId)
            assert exp_row[0] ==0, "Export Id = {} is already closed.".format(exportId)

            # now obtain list of jobs which can be imported.
            cur.execute("SELECT GeomId,CalcDir FROM ExpCalc where ExpId=?",(exportId,))
            toImportList = cur.fetchall()
            importCount = 0
            for geomId, calcDir in toImportList:
                if calcDir in calcDirsDone:

                    dirFull = ExportDir + "/" + calcDir
                    cFiles = glob(dirFull+"/*.calc")
                    assert len(cFiles)==1, "{} must have 1 calc file but has {}.".format(dirFull, len(cFiles))

                    print("Importing ...{}...".format(dirFull), end='')

                    dCalc = parseCalc(cFiles[0])
                    fOut = "{}/{}.out".format(dirFull, dCalc['Basename'])
                    if dCalc["CalcId"]=='1' and parseIteration(fOut, exportId) : # check iteration number for multi before proceeding
                        print("More than 38 iteration skipping import")
                        continue
                    
                    fRes = fOut.replace('.out','res')
                    sResults = parseResult(fRes)

                    a,b,_ = dCalc['Basename'].split('-')              # a base name `multinact2-geom111-1` will go `GeomData/geom111/multinact2`
                    destCalcDir = DataDir+"/{}/{}".format(b,a)

                    tcalc = (dCalc["GeomId"],dCalc["CalcId"], destCalcDir, dCalc["StartGId"],sResults)
                    cur.execute("INSERT INTO Calc (GeomId,CalcId,Dir,StartGId,Results) VALUES (?, ?, ?, ?, ?)", tcalc)

                    moveFiles(dirFull,destCalcDir, ignoreList, zipped)
                    print("done.")

                    cur.execute('DELETE FROM ExpCalc WHERE ExpId=? AND GeomId=? ',(exportId,geomId))
                    importCount += 1
                    
                    if isDel: shutil.rmtree(dirFull)

            sImpGeomIds =''# update what geometries are imported with this exportid, to be handled later
            cur.execute("UPDATE Exports SET ImpDT=datetime('now','localtime'), ImpGeomIds=? WHERE Id=?",(sImpGeomIds,exportId))


            cur.execute("SELECT count(*) FROM ExpCalc WHERE ExpId=?",(exportId,))

            if cur.fetchone()[0]==0:
                cur.execute("UPDATE Exports SET Status=1 WHERE Id=?",(exportId,))
                print('Export Id={} is now closed.'.format(exportId))
                if isDel: shutil.rmtree(ExportDir)
            else :
                print('Export Id={} is not closed.'.format(exportId))

            print("{} Job(s) have been successfully imported.\n ".format(importCount))
    # except Exception as e:
    #     print( "Can't complete Import. {}: {}".format(type(e).__name__, e))


def parseIteration(file, eId):
    try:
        with open(file) as f:
            txt = f.read()
        val = re.findall('\s*(\d+).*\n\n\s*\*\* WVFN \*\*\*\*', txt)[0]
        if val>38:      # if more than 38 then this true will tell the main function to ignore
            return True
        with open('IterMultiJobs.dat', 'a') as f:
            f.write('{} with Export ID {} has {} iterations.\n'.format(file, eId, val))
    except Exception as e:
        print( "Can't parse multi iteration number. {}: {}".format(type(e).__name__, e))


def parseCalc(calcFile):
    with open(calcFile,'r') as f:
        txt = f.read().split("\n")[1:]      #first line comment
    return dict([map(str.strip, i.split(":")) for i in txt])



def moveFiles(calcDir,DestCalcDir, ignoreList, zipped):
    if not os.path.exists(destCalcDir):  os.makedirs(destCalcDir)

    for iFile in glob("{}/*.*".format(calcDir)):
        if os.path.splitext(iFile)[1] in ignoreList:  # copy all file except for ignore list
            continue
        oFile = destCalcDir + "/" + re.sub('-\d+','',os.path.basename(iFile)) 
        shutil.copy(iFile, oFile)
    if zipped:
        shutil.make_archive(destCalcDir, 'bztar', root_dir=destCalcDir, base_dir='./')
        shutil.rmtree(destCalcDir)






# def ImportCalc(cur,CalcDir,CalcFile,DataDir,ignoreList, zipped):

#     with open(CalcFile,'r') as f:
#         txt = f.read().split("\n")[1:] #first line comment
#     dCalc = dict([map(str.strip, i.split(":")) for i in txt])

#     a,b,_ = dCalc['Basename'].split('-')              # a base name `multinact2-geom111-1` will go `GeomData/geom111/multinact2`
#     DestCalcDir = DataDir+"/{}/{}".format(b,a)
#     fRes = "{}/{}.res".format(CalcDir, dCalc['Basename'])
#     sResults = parseResult(fRes)
#     fOut = fRes.replace('.com','.out')
#     if parseIteration(fOut): return True

#     if not os.path.exists(DestCalcDir):  os.makedirs(DestCalcDir)

#     tcalc = (dCalc["GeomId"],dCalc["CalcId"], DestCalcDir, dCalc["StartGId"],sResults)
#     cur.execute("INSERT INTO Calc (GeomId,CalcId,Dir,StartGId,Results) VALUES (?, ?, ?, ?, ?)", tcalc) 

#     for iFile in glob("{}/*.*".format(CalcDir)):
#         if os.path.splitext(iFile)[1] in ignoreList:  # copy all file except for ignore list
#             continue
#         oFile = DestCalcDir + "/" + re.sub('-\d+','',os.path.basename(iFile)) 
#         shutil.copy(iFile, oFile)
#     if zipped:
#         shutil.make_archive(DestCalcDir, 'bztar', root_dir=DestCalcDir, base_dir='./')
#         shutil.rmtree(DestCalcDir)